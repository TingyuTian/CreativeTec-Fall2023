<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Project 1 Documentation</title>
        <style>
            img{
                width: 60%;
                height: auto;
            }
        </style>
    </head>
    <body>
        <h1>Project 1: Kluding as an approach to technology</h1>
        <p>Diagram of Installation Study for Project 1</p>
        <img src="Diagram-02.png" alt="A Diagram of a Installation Study">
        
        <p>emulation of page tuning using ml5.handpose</p> 
        <iframe style="width: 680px; height: 600px; overflow: hidden;"Â  scrolling="no" frameborder="0" src="https://editor.p5js.org/TingyuTian/full/vDPd5sUhV"></iframe>
        <p>let handpose;
            let video;
            let predictions = [];
            let x;
            let easing = 0.2;
            // Page number counting unsolved
            //let PageNum = 0;
            //let width = 640;
            
            let thumbTipX;
            let thumbTipY;
            // const options = {flipHorizontal:true}
            
            function setup() {
              createCanvas(640, 480);
              video = createCapture(VIDEO);
              video.size(width, height);
            
              handpose = ml5.handpose(video, { flipHorizontal: true }, readyNow);
            
              // This sets up an event that fills the global variable "predictions"
              // with an array every time new hand poses are detected
              handpose.on("predict", (results) => {
                predictions = results;
              });
            
              // Hide the video element, and just show the canvas
              video.hide();
            
              thumbTipX = width / 2;
              thumbTipY = height / 2;
              x = width / 2;
            }
            
            function readyNow() {
              console.log("Model ready!");
            }
            
            function draw() {
              image(ml5.flipImage(video), 0, 0, width, height);
              // image(video, 0, 0, width, height)
            
              // We can call both functions to draw all keypoints and the skeletons
              drawKeypoints();
              // thumbTipX = int(thumbTipX*0.1)*10;
              // thumbTipY = int(thumbTipY*0.1)*10;
              let dx = thumbTipX - x;
              x += dx * easing;
              fill(0, 0, 255);
              stroke(0, 0, 255);
              beginShape();
              vertex(width / 2, 0);
              vertex(x, 0);
              vertex(x, 480);
              vertex(width / 2, 480);
              endShape(CLOSE);
            
              //while (true) {
              //   if (x < width / 2 && thumbTipX > width / 2) {
              //     PageNum += 1;
              //   } else if (x > width && thumbTipX < width / 2) {
              //     PageNum = PageNum - 1;
              //   }
              //   console.log(PageNum);
              //  }
            
              // for (let i = 0; i <= 1; i += 0.05) {
              //   let vertexB = lerp(oldthumbTipX, thumbTipX, i);
              //   console.log (vertexB)
              //   fill(0, 0, 255);
              //   stroke(0, 0, 255);
              //   beginShape();
              //   vertex(width / 2, 0);
              //   vertex(vertexB, 0);
              //   vertex(vertexB, 480);
              //   vertex(width / 2, 480);
              //   endShape(CLOSE);
              // }
            }
            
            //   Page number counting
            // for (i = 0; i < 100; i += 1) {
            //while (true) {
            //if (x < width / 2 && thumbTipX > width / 2) {
            //  PageNum += 1;
            //} else if (x > width && thumbTipX < width / 2) {
            //  PageNum = PageNum - 1;
            //}
            //console.log(PageNum);
            //}
            // }
            
            // A function to draw ellipses over the detected keypoints
            function drawKeypoints() {
              for (let i = 0; i < predictions.length; i += 1) {
                const prediction = predictions[i];
            
                for (let j = 0; j < prediction.landmarks.length; j += 1) {
                  const keypoint = prediction.landmarks[j];
                  fill(0, 255, 0);
                  noStroke();
                  ellipse(keypoint[0] - width, keypoint[1], 10, 10);
                }
                //console.log(prediction.annotations.thumb);
                // x = thumbTipX
                thumbTipX = prediction.annotations.thumb[3][0];
                thumbTipY = prediction.annotations.thumb[3][1];
                // thumbTipX = int(prediction.annotations.thumb[3][0]);
                // thumbTipY = int(prediction.annotations.thumb[3][1]);
                // map(thumbTipX, 0, 640, 0, 200, true);
                thumbTipX = int(thumbTipX * 0.1) * 10;
                thumbTipY = int(thumbTipY * 0.1) * 10;
                // console.log(thumbTipX);
                // fill(255, 0, 0);
                // circle(thumbTipX, thumbTipY, 10);
            
                //ThumbTip Change color after the midle point
                // if (thumbTipX <= width / 2) {
                //   fill(0, 0, 255);
                //   circle(thumbTipX - width, thumbTipY, 10);
                // } else {
                //   fill(255, 0, 0);
                //   circle(thumbTipX - width, thumbTipY, 10);
                // }
            
                // rect(thumbTipX - width, 0, thumbTipX - width*1.5, height);
                // }
              }
            }
            </p>
    </body>
</html>